"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tree = void 0;
const constants_1 = require("./constants");
const Node_1 = require("./Node");
class Tree {
    constructor(root) {
        this.root = typeof root === 'string' ? new Node_1.Node(root) : root;
    }
    add(path, listener) {
        let node = this.root;
        for (const pathItem of path) {
            node = node.createOrGetChild(pathItem);
        }
        node.addListeners(listener);
    }
    get(path) {
        let node = this.root;
        for (const pathItem of path) {
            const currentNode = node.getChild(pathItem);
            if (currentNode === undefined) {
                throw new Error('Could not get child');
            }
            node = currentNode;
        }
        return node;
    }
    toString() {
        const ret = [];
        function it(node, level) {
            const pad = new Array(level).join('-');
            ret.push(`${pad} ${node.name} l:${node.listeners.length}`);
            node.children.forEach((child) => {
                it(child, level + 2);
            });
        }
        it(this.root, 2);
        return ret.join('\n');
    }
    getCloneExpanded() {
        const clone = new Tree(this.root.clone());
        this.expandWildcards(clone.root);
        return clone;
    }
    expandWildcards(node) {
        const wildNode = node.getChild(constants_1.WILDCARD);
        if (wildNode !== undefined) {
            node.children.forEach((child) => {
                if (child.name !== constants_1.WILDCARD) {
                    child.addListeners(wildNode.listeners);
                    this.mergeNodes(child, wildNode);
                }
            });
        }
        node.children.forEach((child) => this.expandWildcards(child));
    }
    mergeNodes(target, source) {
        source.children.forEach((sourceChild) => {
            const targetChild = target.createOrGetChild(sourceChild.name);
            targetChild.addListeners(sourceChild.listeners);
            this.mergeNodes(targetChild, sourceChild);
        });
    }
}
exports.Tree = Tree;
