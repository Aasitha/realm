import Realm from 'realm';
import { ModelsList, RealmsStore, Methods as RealmsStoreMethods } from './realms-collection';
import * as Errors from './errors';
import fs from 'fs/promises';
import fsRaw from 'fs';
import { KeusRealtimeCommunication, ConnectionEvents } from '@keus-automation/kiotp-realtime-js';

export namespace IRealmServer {
    export interface RealmServiceModel {
        BaseSchemaName: string;
        BaseSchemaVersion: number;
        Methods: any;
        ModelsList: Array<any>;
    }

    export interface IServerOptions {
        storageFolder: string;
        host?: string;
        port?: number;
        token?: string;
        serverId?: string;
        disableService: boolean;
    }

    export interface RealmInfo {
        realm: Realm;
        model: RealmServiceModel;
    }

    export enum IRealmAction {
        create = 1,
        delete = 2,
        update = 3
    }

    export interface IRealmRequest {
        realmName: string;
        realmModel?: string;
        schemaVersion: number;
        action: IRealmAction;
    }

    export interface IRealmResponse {
        success: boolean;
        error?: any;
    }

    export interface IDBRequest {
        realmName: string;
        methodName: string;
        methodData: any;
    }

    export interface IDBResponse {
        success: boolean;
        data: any;
        error?: any;
    }
}

const REALMS_DB = 'realms_db';

class RealmServer {
    _options: IRealmServer.IServerOptions;
    _realtimeInst: KeusRealtimeCommunication;
    _storageFolder: string;
    _realmsDb?: Realm;
    _realms: Map<string, IRealmServer.RealmInfo> = new Map();
    _serverId: string;

    constructor(options: IRealmServer.IServerOptions) {
        this._options = options;
        this._storageFolder = options.storageFolder;
        this._serverId = options.serverId;

        if (!this._options.disableService) {
            this._realtimeInst = new KeusRealtimeCommunication({
                host: options.host,
                port: options.port,
                token: options.token
            });

            this._realtimeInst.on(ConnectionEvents.CONNECTED, async () => {
                console.log('connected');
                await this.startDbProviders();
            });
        }
    }

    async start() {
        this._realmsDb = await Realm.open({
            path: `${this._storageFolder}/${REALMS_DB}/db.realm`,
            //@ts-ignore
            schema: ModelsList
        });
        let existingRealmsList = await RealmsStoreMethods.getRealmsList(this._realmsDb);

        console.log(existingRealmsList);

        for (let i = 0; i < existingRealmsList.length; i++) {
            let realmDbInfo = <RealmsStore> <unknown> existingRealmsList[i];
            let realmModelsList = await import(realmDbInfo.realmModelPath);
            let realmDbInst = await Realm.open({
                path: realmDbInfo.realmPath,
                schema: realmModelsList.ModelsList,
                schemaVersion: realmDbInfo.schemaVersion
            });

            console.log(realmModelsList, realmDbInfo, realmDbInst, realmDbInfo.schemaVersion);

            this._realms.set(realmDbInfo.realmName, {
                realm: realmDbInst,
                model: realmModelsList
            });
        }

        if (!this._options.disableService) {
            await this._realtimeInst.connect();
        }
    }

    async startDbProviders() {
        this._realtimeInst.jsonProvideRPC<IRealmServer.IRealmRequest, IRealmServer.IRealmResponse>
            (`${this._serverId}-realm`, async (data) => {
            let success = false, error = null;

            try {
                if (data.action === IRealmServer.IRealmAction.create) {
                    await this.createRealm(data);
                } else if (data.action === IRealmServer.IRealmAction.delete) {
                    await this.deleteRealm(data.realmName);
                } else if (data.action === IRealmServer.IRealmAction.update) {
                    await this.updateRealm(data);
                }

                success = true;
            } catch (err) {
                console.log(err);
                error = err;
            }

            return {
                success,
                error
            }
        });
        this._realtimeInst.jsonProvideRPC<IRealmServer.IDBRequest, IRealmServer.IDBResponse>
            (`${this._serverId}-db`, async (data) => {
            let error = null,
                success = false,
                respData = null;

            try {
                respData = await this.callModelMethod(data);
                success = true;
            } catch (err: any) {
                console.log(err);

                switch (err) {
                    case Errors.RealmNotFound: {
                        error = 'Realm Not Found';
                    }
                    break;

                    default: {
                        error = err;
                    }
                }
            }

            return {
                success,
                data: respData,
                error
            }
        });
    }

    async callModelMethod(data: IRealmServer.IDBRequest) {
        let realmDbInst = this._realms.get(data.realmName);

        if (realmDbInst) {
            console.log('this is model', realmDbInst.model.ModelsList[0]);
            return await realmDbInst.model.Methods[data.methodName](realmDbInst.realm, data.methodData);
        } else {
            throw new Errors.RealmNotFound();
        }
    }

    async addLocalRealm(realmServiceModel: IRealmServer.RealmServiceModel) {
        if (this._realms.has(realmServiceModel.BaseSchemaName)) {
            throw new Errors.DuplicateRealm();
        } else {
            let realmStorageFolder = `${this._options.storageFolder}/${realmServiceModel.BaseSchemaName}`;
            let realmStoragePath = `${realmStorageFolder}/data.realm`;
            let realmDbInst = await Realm.open({
                path: realmStoragePath,
                schema: realmServiceModel.ModelsList,
                schemaVersion: realmServiceModel.BaseSchemaVersion
            });

            this._realms.set(realmServiceModel.BaseSchemaName, {
                model: realmServiceModel,
                realm: realmDbInst
            });
        }
    }

    async createRealm(data: IRealmServer.IRealmRequest) {
        if (!data.realmModel) {
            throw new Errors.InvalidModelFile();
        }

        let realmStorageFolder = `${this._options.storageFolder}/${data.realmName}`;
        if (!fsRaw.existsSync(realmStorageFolder)) {
            await fs.mkdir(realmStorageFolder, {recursive: true});
        }
        let modelFilePath = `${realmStorageFolder}/model.js`;
        let realmStoragePath = `${realmStorageFolder}/data.realm`;
        console.log(modelFilePath, realmStoragePath);

        await fs.writeFile(modelFilePath, data.realmModel, {encoding: 'utf-8'});

        await this.addRealm(<any>{
            realmName: data.realmName,
            realmPath: realmStoragePath,
            realmModelPath: modelFilePath,
            schemaVersion: data.schemaVersion,
            realmFolder: realmStorageFolder
        });
    }

    async addRealm(realmInfo: RealmsStore) {
        if (this._realms.has(realmInfo.realmName)) {
            throw new Errors.DuplicateRealm();
        } else {
            let realmServiceModel = await import(realmInfo.realmModelPath);

            console.log(realmServiceModel);

            let realmDbInst = await Realm.open({
                path: realmInfo.realmPath,
                schema: realmServiceModel.ModelsList,
                schemaVersion: realmInfo.schemaVersion
            });

            this._realms.set(realmInfo.realmName, {
                model: realmServiceModel,
                realm: realmDbInst
            });

            if (this._realmsDb) {
                await RealmsStoreMethods.createNewRealm(this._realmsDb, realmInfo);
            }

            return true;
        }
    }

    async updateRealm(data: IRealmServer.IRealmRequest) {
        if (this._realms.has(data.realmName)) {
            if (!data.realmModel) {
                throw new Errors.InvalidModelFile();
            }

            let realmStorageFolder = `${this._options.storageFolder}/${data.realmName}`;
            if (!fsRaw.existsSync(realmStorageFolder)) {
                await fs.mkdir(realmStorageFolder, {recursive: true});
            }
            let modelFilePath = `${realmStorageFolder}/model.js`;
            let realmStoragePath = `${realmStorageFolder}/data.realm`;
            console.log(modelFilePath, realmStoragePath);

            await fs.rm(modelFilePath);
            await fs.writeFile(modelFilePath, data.realmModel, {encoding: 'utf-8'});
            await RealmsStoreMethods.updateRealmSchemaVersion(this._realmsDb, data.realmName, data.schemaVersion);
            process.exit(0);
        } else {
            throw new Errors.RealmNotFound();
        }
    }

    async deleteRealm(realmName: string) {
        if (this._realms.has(realmName) && this._realmsDb) {
            let realmInfo = <RealmsStore> <unknown> await RealmsStoreMethods.getRealmInfo(this._realmsDb, realmName);
            await fs.rmdir(realmInfo.realmFolder, {recursive: true});
            await RealmsStoreMethods.deleteRealm(this._realmsDb, realmInfo.realmName);
            
            return true;
        } else {
            throw new Errors.RealmNotFound();
        }
    }
}

export { RealmServer };