"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RealmClient = exports.IRealmClient = void 0;
const kiotp_realtime_js_1 = require("@keus-automation/kiotp-realtime-js");
const promises_1 = __importDefault(require("fs/promises"));
var IRealmClient;
(function (IRealmClient) {
    let IRealmAction;
    (function (IRealmAction) {
        IRealmAction[IRealmAction["create"] = 1] = "create";
        IRealmAction[IRealmAction["delete"] = 2] = "delete";
        IRealmAction[IRealmAction["update"] = 3] = "update";
    })(IRealmAction = IRealmClient.IRealmAction || (IRealmClient.IRealmAction = {}));
})(IRealmClient || (exports.IRealmClient = IRealmClient = {}));
class RealmClient {
    constructor(options) {
        this._options = options;
        this._realtimeInst = new kiotp_realtime_js_1.KeusRealtimeCommunication({
            host: options.host,
            port: options.port,
            token: options.token
        });
    }
    getRealmRPC() {
        return `${this._options.serverId}-realm`;
    }
    getRealmMethodRPC() {
        return `${this._options.serverId}-db`;
    }
    async start() {
        await this._realtimeInst.connect();
    }
    async createRealm(realmName, schemaVersion, modelFilePath) {
        console.log(modelFilePath);
        let modelFileStr = await promises_1.default.readFile(modelFilePath, { encoding: 'utf-8' });
        let createRealmResp = await this._realtimeInst.jsonCallRPC(this.getRealmRPC(), {
            action: IRealmClient.IRealmAction.create,
            realmName: realmName,
            schemaVersion: schemaVersion,
            realmModel: modelFileStr
        });
        if (createRealmResp.success) {
            return createRealmResp.data;
        }
        else {
            throw createRealmResp.error;
        }
    }
    async updateRealm(realmName, schemaVersion, modelFilePath) {
        console.log('Updating Realm', modelFilePath);
        let modelFileStr = await promises_1.default.readFile(modelFilePath, { encoding: 'utf-8' });
        let updateRealmResp = await this._realtimeInst.jsonCallRPC(this.getRealmRPC(), {
            action: IRealmClient.IRealmAction.update,
            realmName: realmName,
            schemaVersion: schemaVersion,
            realmModel: modelFileStr
        });
        if (updateRealmResp.success) {
            return updateRealmResp.data;
        }
        else {
            throw updateRealmResp.error;
        }
    }
    async deleteRealm(realmName) {
        let deleteRealmResp = await this._realtimeInst.jsonCallRPC(this.getRealmRPC(), {
            action: IRealmClient.IRealmAction.delete,
            realmName: realmName
        });
        if (deleteRealmResp.success) {
            return deleteRealmResp.data;
        }
        else {
            throw deleteRealmResp.error;
        }
    }
    async callModelMethod(realmName, methodName, methodData) {
        let callModelResp = await this._realtimeInst.jsonCallRPC(this.getRealmMethodRPC(), {
            realmName: realmName,
            methodName: methodName,
            methodData: methodData
        });
        if (callModelResp.success) {
            return callModelResp.data;
        }
        else {
            throw callModelResp.error;
        }
    }
}
exports.RealmClient = RealmClient;
//# sourceMappingURL=index.js.map