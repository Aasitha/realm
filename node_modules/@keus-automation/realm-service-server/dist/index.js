"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RealmServer = exports.IRealmServer = void 0;
const realm_1 = __importDefault(require("realm"));
const realms_collection_1 = require("./realms-collection");
const Errors = __importStar(require("./errors"));
const promises_1 = __importDefault(require("fs/promises"));
const fs_1 = __importDefault(require("fs"));
const kiotp_realtime_js_1 = require("@keus-automation/kiotp-realtime-js");
var IRealmServer;
(function (IRealmServer) {
    let IRealmAction;
    (function (IRealmAction) {
        IRealmAction[IRealmAction["create"] = 1] = "create";
        IRealmAction[IRealmAction["delete"] = 2] = "delete";
        IRealmAction[IRealmAction["update"] = 3] = "update";
    })(IRealmAction = IRealmServer.IRealmAction || (IRealmServer.IRealmAction = {}));
})(IRealmServer || (exports.IRealmServer = IRealmServer = {}));
const REALMS_DB = 'realms_db';
class RealmServer {
    constructor(options) {
        this._realms = new Map();
        this._options = options;
        this._storageFolder = options.storageFolder;
        this._serverId = options.serverId;
        if (!this._options.disableService) {
            this._realtimeInst = new kiotp_realtime_js_1.KeusRealtimeCommunication({
                host: options.host,
                port: options.port,
                token: options.token
            });
            this._realtimeInst.on(kiotp_realtime_js_1.ConnectionEvents.CONNECTED, async () => {
                console.log('connected');
                await this.startDbProviders();
            });
        }
    }
    async start() {
        this._realmsDb = await realm_1.default.open({
            path: `${this._storageFolder}/${REALMS_DB}/db.realm`,
            //@ts-ignore
            schema: realms_collection_1.ModelsList
        });
        let existingRealmsList = await realms_collection_1.Methods.getRealmsList(this._realmsDb);
        console.log(existingRealmsList);
        for (let i = 0; i < existingRealmsList.length; i++) {
            let realmDbInfo = existingRealmsList[i];
            let realmModelsList = await Promise.resolve(`${realmDbInfo.realmModelPath}`).then(s => __importStar(require(s)));
            let realmDbInst = await realm_1.default.open({
                path: realmDbInfo.realmPath,
                schema: realmModelsList.ModelsList,
                schemaVersion: realmDbInfo.schemaVersion
            });
            console.log(realmModelsList, realmDbInfo, realmDbInst, realmDbInfo.schemaVersion);
            this._realms.set(realmDbInfo.realmName, {
                realm: realmDbInst,
                model: realmModelsList
            });
        }
        if (!this._options.disableService) {
            await this._realtimeInst.connect();
        }
    }
    async startDbProviders() {
        this._realtimeInst.jsonProvideRPC(`${this._serverId}-realm`, async (data) => {
            let success = false, error = null;
            try {
                if (data.action === IRealmServer.IRealmAction.create) {
                    await this.createRealm(data);
                }
                else if (data.action === IRealmServer.IRealmAction.delete) {
                    await this.deleteRealm(data.realmName);
                }
                else if (data.action === IRealmServer.IRealmAction.update) {
                    await this.updateRealm(data);
                }
                success = true;
            }
            catch (err) {
                console.log(err);
                error = err;
            }
            return {
                success,
                error
            };
        });
        this._realtimeInst.jsonProvideRPC(`${this._serverId}-db`, async (data) => {
            let error = null, success = false, respData = null;
            try {
                respData = await this.callModelMethod(data);
                success = true;
            }
            catch (err) {
                console.log(err);
                switch (err) {
                    case Errors.RealmNotFound:
                        {
                            error = 'Realm Not Found';
                        }
                        break;
                    default: {
                        error = err;
                    }
                }
            }
            return {
                success,
                data: respData,
                error
            };
        });
    }
    async callModelMethod(data) {
        let realmDbInst = this._realms.get(data.realmName);
        if (realmDbInst) {
            console.log('this is model', realmDbInst.model.ModelsList[0]);
            return await realmDbInst.model.Methods[data.methodName](realmDbInst.realm, data.methodData);
        }
        else {
            throw new Errors.RealmNotFound();
        }
    }
    async addLocalRealm(realmServiceModel) {
        if (this._realms.has(realmServiceModel.BaseSchemaName)) {
            throw new Errors.DuplicateRealm();
        }
        else {
            let realmStorageFolder = `${this._options.storageFolder}/${realmServiceModel.BaseSchemaName}`;
            let realmStoragePath = `${realmStorageFolder}/data.realm`;
            let realmDbInst = await realm_1.default.open({
                path: realmStoragePath,
                schema: realmServiceModel.ModelsList,
                schemaVersion: realmServiceModel.BaseSchemaVersion
            });
            this._realms.set(realmServiceModel.BaseSchemaName, {
                model: realmServiceModel,
                realm: realmDbInst
            });
        }
    }
    async createRealm(data) {
        if (!data.realmModel) {
            throw new Errors.InvalidModelFile();
        }
        let realmStorageFolder = `${this._options.storageFolder}/${data.realmName}`;
        if (!fs_1.default.existsSync(realmStorageFolder)) {
            await promises_1.default.mkdir(realmStorageFolder, { recursive: true });
        }
        let modelFilePath = `${realmStorageFolder}/model.js`;
        let realmStoragePath = `${realmStorageFolder}/data.realm`;
        console.log(modelFilePath, realmStoragePath);
        await promises_1.default.writeFile(modelFilePath, data.realmModel, { encoding: 'utf-8' });
        await this.addRealm({
            realmName: data.realmName,
            realmPath: realmStoragePath,
            realmModelPath: modelFilePath,
            schemaVersion: data.schemaVersion,
            realmFolder: realmStorageFolder
        });
    }
    async addRealm(realmInfo) {
        if (this._realms.has(realmInfo.realmName)) {
            throw new Errors.DuplicateRealm();
        }
        else {
            let realmServiceModel = await Promise.resolve(`${realmInfo.realmModelPath}`).then(s => __importStar(require(s)));
            console.log(realmServiceModel);
            let realmDbInst = await realm_1.default.open({
                path: realmInfo.realmPath,
                schema: realmServiceModel.ModelsList,
                schemaVersion: realmInfo.schemaVersion
            });
            this._realms.set(realmInfo.realmName, {
                model: realmServiceModel,
                realm: realmDbInst
            });
            if (this._realmsDb) {
                await realms_collection_1.Methods.createNewRealm(this._realmsDb, realmInfo);
            }
            return true;
        }
    }
    async updateRealm(data) {
        if (this._realms.has(data.realmName)) {
            if (!data.realmModel) {
                throw new Errors.InvalidModelFile();
            }
            let realmStorageFolder = `${this._options.storageFolder}/${data.realmName}`;
            if (!fs_1.default.existsSync(realmStorageFolder)) {
                await promises_1.default.mkdir(realmStorageFolder, { recursive: true });
            }
            let modelFilePath = `${realmStorageFolder}/model.js`;
            let realmStoragePath = `${realmStorageFolder}/data.realm`;
            console.log(modelFilePath, realmStoragePath);
            await promises_1.default.rm(modelFilePath);
            await promises_1.default.writeFile(modelFilePath, data.realmModel, { encoding: 'utf-8' });
            await realms_collection_1.Methods.updateRealmSchemaVersion(this._realmsDb, data.realmName, data.schemaVersion);
            process.exit(0);
        }
        else {
            throw new Errors.RealmNotFound();
        }
    }
    async deleteRealm(realmName) {
        if (this._realms.has(realmName) && this._realmsDb) {
            let realmInfo = await realms_collection_1.Methods.getRealmInfo(this._realmsDb, realmName);
            await promises_1.default.rmdir(realmInfo.realmFolder, { recursive: true });
            await realms_collection_1.Methods.deleteRealm(this._realmsDb, realmInfo.realmName);
            return true;
        }
        else {
            throw new Errors.RealmNotFound();
        }
    }
}
exports.RealmServer = RealmServer;
//# sourceMappingURL=index.js.map