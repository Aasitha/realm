import { KeusRealtimeCommunication, ConnectionEvents } from '@keus-automation/kiotp-realtime-js';
import fs from 'fs/promises';

export namespace IRealmClient {
    export interface IClientOptions {
        host: string;
        port: number;
        token: string;
        serverId: string;
    }

    export enum IRealmAction {
        create = 1,
        delete = 2,
        update = 3
    }

    export interface IRealmRequest {
        realmName: string;
        realmModel?: string;
        schemaVersion?: number;
        action: IRealmAction;
    }

    export interface IRealmResponse {
        success: boolean;
        error?: any;
    }

    export interface IDBRequest {
        realmName: string;
        methodName: string;
        methodData: any;
    }

    export interface IDBResponse {
        success: boolean;
        data: any;
        error?: any;
    }
}

class RealmClient {
    _options: IRealmClient.IClientOptions;
    _realtimeInst: KeusRealtimeCommunication;

    constructor(options: IRealmClient.IClientOptions) {
        this._options = options;
        this._realtimeInst = new KeusRealtimeCommunication({
            host: options.host,
            port: options.port,
            token: options.token
        });
    }

    getRealmRPC() {
        return `${this._options.serverId}-realm`
    }

    getRealmMethodRPC() {
        return `${this._options.serverId}-db`
    }

    async start() {
        await this._realtimeInst.connect();
    }

    async createRealm(realmName: string, schemaVersion: number, modelFilePath: string) {
        console.log(modelFilePath);
        let modelFileStr = await fs.readFile(modelFilePath, {encoding: 'utf-8'});
        let createRealmResp = await this._realtimeInst.jsonCallRPC<IRealmClient.IRealmRequest, IRealmClient.IRealmResponse>(
            this.getRealmRPC(), {
            action: IRealmClient.IRealmAction.create,
            realmName: realmName,
            schemaVersion: schemaVersion,
            realmModel: modelFileStr
        });

        if (createRealmResp.success) {
            return createRealmResp.data;
        } else {
            throw createRealmResp.error;
        }
    }

    async updateRealm(realmName: string, schemaVersion: number, modelFilePath: string) {
        console.log('Updating Realm', modelFilePath);
        let modelFileStr = await fs.readFile(modelFilePath, {encoding: 'utf-8'});
        let updateRealmResp = await this._realtimeInst.jsonCallRPC<IRealmClient.IRealmRequest, IRealmClient.IRealmResponse>(
            this.getRealmRPC(), {
            action: IRealmClient.IRealmAction.update,
            realmName: realmName,
            schemaVersion: schemaVersion,
            realmModel: modelFileStr
        });

        if (updateRealmResp.success) {
            return updateRealmResp.data;
        } else {
            throw updateRealmResp.error;
        }
    }

    async deleteRealm(realmName: string) {
        let deleteRealmResp = await this._realtimeInst.jsonCallRPC<IRealmClient.IRealmRequest, IRealmClient.IRealmResponse>(
            this.getRealmRPC(), {
            action: IRealmClient.IRealmAction.delete,
            realmName: realmName
        });

        if (deleteRealmResp.success) {
            return deleteRealmResp.data;
        } else {
            throw deleteRealmResp.error;
        }
    }

    async callModelMethod<IMethodData>(realmName: string, methodName: string, methodData: IMethodData) {
        let callModelResp = await this._realtimeInst.jsonCallRPC<IRealmClient.IDBRequest, IRealmClient.IDBResponse>(
            this.getRealmMethodRPC(), {
            realmName: realmName,
            methodName: methodName,
            methodData: methodData
        });

        if (callModelResp.success) {
            return callModelResp.data;
        } else {
            throw callModelResp.error;
        }
    }
}

export { RealmClient };