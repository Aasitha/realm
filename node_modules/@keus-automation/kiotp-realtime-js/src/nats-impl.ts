import {
    Errors,
    IKIOTPRealtimeCommunication,
    RPCBinaryResponse,
    RPCJSONResponse,
    RPCStringResponse,
    Tconfig,
    TEventDataReceiveFunction,
    TMethodHandlerFunction,
    ConnectionEvents
} from './realtime-interface';
import { NatsConnection, StringCodec, connect, nkeyAuthenticator, JSONCodec, Subscription } from './nats-export';
import { Events } from './nats-export';
import { Buffer } from 'buffer/';

class KIOTPRealtimeCommunication extends IKIOTPRealtimeCommunication {
    host: string;
    port: number;
    token: string = '';
    tokenFlag: boolean = false;
    nkey: string = '';
    connection: NatsConnection | null = null;
    sc = StringCodec();
    jc = JSONCodec();

    asyncDelay(delay: number): Promise<void> {
        return new Promise(function(resolve) {
            setTimeout(function() {
                resolve();
            }, delay);
        });
    }
    
    constructor(config: Tconfig) {
        super(config);
        this.host = config.host;
        this.port = config.port;
        if (config.token) {
            this.token = config.token;
            this.tokenFlag = true;
        } else {
            this.nkey = config?.nkey || '';
        }
    }

    async attachConnectionListeners() {
        if (this.connection?.status) {
            this.emit(ConnectionEvents.CONNECTED);

            for await (const status of this.connection?.status()) {
                switch (status.type) {
                    case Events.Disconnect:
                    {
                        this.emit(ConnectionEvents.RECONNECTING);
                    }
                    break;

                    case Events.Reconnect:
                    {
                        this.emit(ConnectionEvents.CONNECTED);
                    }
                    break;

                    case Events.Error:
                    {
                        this.emit(ConnectionEvents.ERROR, status.data);
                    }
                    break;

                    case Events.Update:
                    {
                        console.log('Cluster Updated', status.data);
                    }
                    break;
                }
            }
        }
    }

    async connect(): Promise<boolean> {
        try {
            if (this.tokenFlag) {
                this.connection = await connect({
                    servers: `${this.host}:${this.port}`,
                    token: this.token,
                    maxReconnectAttempts: 5,
                    reconnect: true
                });
            }
            else {
                this.connection = await connect({
                    servers: `${this.host}:${this.port}`,
                    authenticator: nkeyAuthenticator(new TextEncoder().encode(this.nkey)),
                    maxReconnectAttempts: 5,
                    reconnect: true
                });
            }

            this.attachConnectionListeners();
        } catch (e) {
            console.log('from conect', e);
            await this.asyncDelay(4000);
            this.connect();
        }

        return true;
    }

    private async processBinaryProvidedRPC(key: string, methodHandlerFunction: any, value: Subscription) {
        for await (const items of value) {
            let data = items.data;

            methodHandlerFunction(data)
            .then(function(response: any) {
                items.respond(response);
            })
            .catch(function(err: any) {
                items.respond(Buffer.from(err.toString()));
            });
        }
    }

    private async processJsonProvidedRPC(key: string, methodHandlerFunction: any, value: Subscription) {
        for await (const items of value) {
            let data: Uint8Array = items.data;
            let jsonData;

            try {
                jsonData = this.jc.decode(data);
            } catch (err) {
                console.log(err);
            }

            methodHandlerFunction(jsonData)
            .then((response: any) => {
                let jsonRespData = this.jc.encode(response);
                items.respond(jsonRespData);
            })
            .catch((err: any) => {
                items.respond(this.jc.encode({
                    success: false,
                    error: Errors.InvalidDataFormat.getErrorCode()
                }));
            });
        }
    }

    private async processStringProvidedRPC(key: string, methodHandlerFunction: any, value: any) {
        for await (const items of value) {
            let data = this.sc.decode(items.data);

            methodHandlerFunction(data)
            .then((response: any) => {
                items.respond(this.sc.encode(response))
            })
            .catch((err: any) => {
                items.response(this.sc.encode(err.toString()));
            });
        }
    }

    async stringProvideRPC(key: string, methodHandlerFunction: TMethodHandlerFunction<string, string>): Promise<boolean> {
        try {
            let value = await this.connection?.subscribe(key);

            if (!value) {
                throw new Errors.InvalidConnection();
            }

            this.processStringProvidedRPC(key, methodHandlerFunction, value);

            return true;
        } catch (e) {
            console.log('from providerpc', e)
            return false;
        }
    }

    async jsonProvideRPC<JSONReqData, JSONRespData>(key: string, methodHandlerFunction: TMethodHandlerFunction<JSONReqData, JSONRespData>): Promise<boolean> {
        try {
            let value = await this.connection?.subscribe(key);

            if (!value) {
                throw new Errors.InvalidConnection();
            }

            this.processJsonProvidedRPC(key, methodHandlerFunction, value);

            return true
        } catch (e) {
            console.log('from providerpc', e)
            return false;
        }
    }

    async binaryProvideRPC(key: string, methodHandlerFunction: TMethodHandlerFunction<Buffer, Buffer>): Promise<boolean> {
        try {
            let value = await this.connection?.subscribe(key);

            if (!value) {
                throw new Errors.InvalidConnection();
            }

            this.processBinaryProvidedRPC(key, methodHandlerFunction, value);

            return true
        } catch (e) {
            console.log('from providerpc', e)
            return false;
        }
    }

    async unsubscribe() {
        try {
            await this.connection?.drain()
        }
        catch (e) {
            console.log('from unsubsribe', e)
        }
    }

    async binaryCallRPC(key: string, methodData: Buffer): Promise<RPCBinaryResponse> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }
            let msg = await this.connection?.request(key, methodData, { timeout: 30000 });

            return {
                success: true,
                data: Buffer.from(msg.data)
            }
        } catch (err: any) {
            if (err && err.code == 503) {
                return {
                    success: false,
                    error: new Errors.RPCNotAvailable()
                }
            } else {
                return {
                    success: false,
                    error: err.toString()
                }
            }
        }
    }

    async jsonCallRPC<JSONReqData, JSONRespData>(key: string, methodData: JSONReqData): Promise<RPCJSONResponse<JSONRespData>> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }
            let reqData = this.jc.encode(methodData);
            let msg = await this.connection?.request(key, reqData, { timeout: 30000 })
            let jsonRespData = <JSONRespData> this.jc.decode(msg.data);

            return {
                success: true,
                data: jsonRespData
            }
        } catch (err: any) {
            if (err && err.code == 503) {
                return {
                    success: false,
                    error: new Errors.RPCNotAvailable()
                }
            } else {
                return {
                    success: false,
                    error: err.toString()
                }
            }
        }
    }

    async stringCallRPC(key: string, methodData: string): Promise<RPCStringResponse> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }
            let reqData = this.sc.encode(methodData);
            let msg = await this.connection?.request(key, reqData, { timeout: 30000 })
            let stringRespData = this.sc.decode(msg.data);

            return {
                success: true,
                data: stringRespData
            }
        } catch (err: any) {
            if (err && err.code == 503) {
                return {
                    success: false,
                    error: new Errors.RPCNotAvailable()
                }
            } else {
                return {
                    success: false,
                    error: err.toString()
                }
            }
        }
    }

    private async emitStringEvents(value: Subscription, listener: TEventDataReceiveFunction<string>) {
        for await (const items of value) {
            let eventData = this.sc.decode(items.data);
            listener(eventData);
        }
    }

    async stringListenToEvents(key: string, listener: TEventDataReceiveFunction<string>): Promise<boolean> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }

            const sub = await this.connection.subscribe(key);

            if (sub) {
                this.emitStringEvents(sub, listener);

                return true;
            } else {
                return false;
            }
        } catch (e) {
            console.log('from listen', e)
            return false;
        }
    }

    async stringPublishEvents(key: string, message: string): Promise<boolean> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }

            await this.connection.publish(key, this.sc.encode(message));
            return true;
        }
        catch (e) {
            console.log('from publish', e)
            return false;
        }
    }

    private async emitJSONEvents<EventData>(value: Subscription, listener: TEventDataReceiveFunction<EventData>) {
        for await (const items of value) {
            let eventData = <EventData> this.jc.decode(items.data);
            listener(eventData);
        }
    }

    async jsonListenToEvents<EventData>(key: string, listener: TEventDataReceiveFunction<EventData>): Promise<boolean> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }

            const sub = await this.connection.subscribe(key);

            if (sub) {
                this.emitJSONEvents(sub, listener);

                return true;
            } else {
                return false;
            }
        } catch (e) {
            console.log('from listen', e)
            return false;
        }
    }

    async jsonPublishEvents<EventData>(key: string, message: EventData): Promise<boolean> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }

            await this.connection.publish(key, this.jc.encode(message));

            return true;
        }
        catch (e) {
            console.log('from publish', e)
            return false;
        }
    }

    private async emitBinaryEvents(value: Subscription, listener: TEventDataReceiveFunction<Buffer>) {
        for await (const items of value) {
            listener(Buffer.from(items.data));
        }
    }

    async binaryListenToEvents(key: string, listener: TEventDataReceiveFunction<Buffer>): Promise<boolean> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }

            const sub = await this.connection.subscribe(key);

            if (sub) {
                this.emitBinaryEvents(sub, listener);

                return true;
            } else {
                return false;
            }
        } catch (e) {
            console.log('from listen', e)
            return false;
        }
    }

    async binaryPublishEvents(key: string, message: Buffer): Promise<boolean> {
        try {
            if (!this.connection) {
                throw new Errors.InvalidConnection();
            }

            await this.connection.publish(key, message);
            return true;
        }
        catch (e) {
            console.log('from publish', e)
            return false;
        }
    }
}

export default KIOTPRealtimeCommunication;
